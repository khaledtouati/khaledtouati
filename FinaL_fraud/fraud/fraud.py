# -*- coding: utf-8 -*-
"""Fraud.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1wRFXwmVYrVKg3Wy4I3pf8GtV6UD3kHqZ
"""

import sys
import numpy
import pandas
import matplotlib
import seaborn
import scipy

import numpy as np # linear algebra
import pandas as pd

from google.colab import files
  
  
uploaded = files.upload()

import pandas as pd
import io

df = pd.read_csv(io.BytesIO(uploaded['primary_transaction(1).csv']))
print(df)

df.head()

df.shape

print(df.columns)

df = df.sample(frac=0.9, random_state = 1) # taking only one percent of data 
print(df.shape)
print(df.describe())

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import seaborn as sns

df.hist(figsize = (20, 20))
plt.show()



# Determine number of fraud cases in dataset

Fraud = df[df['amount'] == 5]
Valid = df[df['amount'] >10]

outlier_fraction = len(Fraud)/float(len(Valid))
print(outlier_fraction)

print('Fraud Cases: {}'.format(len(df[df['amount'] == 5])))
print('Valid Transactions: {}'.format(len(df[df['amount'] > 10])))

corrmat = df.corr()
fig = plt.figure(figsize = (12, 9))

sns.heatmap(corrmat, vmax = .8, square = True)
plt.show()

# Get all the columns from the dataFrame
columns = df.columns.tolist()

# Filter the columns to remove data we do not want
columns = [c for c in columns if c != 'amount' and c != 'date' and c !='description' and c !='status' and c !='type']

# Store the variable we'll be predicting on
target = "amount"

X = df[columns]
Y = df[target]
print(X)
print(Y)
# Print shapes
print(X.shape)
print(Y.shape)

import sklearn
from sklearn.metrics import accuracy_score, classification_report
from sklearn.ensemble import IsolationForest
from sklearn.neighbors import LocalOutlierFactor

# define random states
state = 1

classifier = {
    'isolation_forest':IsolationForest(max_samples=len(X), contamination=outlier_fraction,
                                      random_state = state),
                                      
    'local_outlierfactor':LocalOutlierFactor(
    n_neighbors=20 , contamination= outlier_fraction, novelty=True
    )
}

# the model dont know yet that how many outliers are there in our X data 
plt.figure(figsize=(9, 7))
n_outliers = len(Fraud)

for i ,(clf_name, clf) in enumerate(classifier.items()):
    if clf_name == 'localoutlierfactor':
        y_pred = clf.fit_predict(X)
        scores_pred = clf.negative_outlier_factor_
    else:
        clf.fit(X)
        scores_pred = clf.decision_function(X)
        y_pred = clf.predict(X)
        
    # Reshape the prediction values to 0 for valid, 1 for fraud. 
    y_pred[y_pred == 1] = 0
    y_pred[y_pred == -1] = 1    
    
    
    n_errors = (y_pred != Y).sum()
    
    # Run classification metrics
    print('{}: {}'.format(clf_name, n_errors))
    print(accuracy_score(Y, y_pred))
    print(classification_report(Y, y_pred))

df.info()

df.isnull().any()

import matplotlib.pyplot as plt 
import seaborn as sns

sns.histplot(df['amount'],bins =40,color="green")
sns.set_style("darkgrid")



sns.set_style("whitegrid")
df["log_amount"] = np.log2(df["amount"]+0.01)
sns.displot(x = "log_amount",bins = 25, kde = True, hue = "available_balance", data=df)

sns.set_style("ticks")
fig,ax  = plt.subplots(ncols = 2,nrows =1,figsize = (10,10))
ax.flatten()
sns.boxplot(x = "available_balance", y = "amount", data=df, ax = ax[0])
sns.boxplot(x = "available_balance",y = "log_amount", data =df, ax = ax[1])

"""sns.set_style("darkgrid")
plt.figure(figsize = (10,6))
sns.countplot(x = "amount", data=df)
"""

sns.set_style("darkgrid")
plt.figure(figsize = (10,6))
sns.countplot(x = "amount", data=df)

# Determine number of fraud cases in dataset

fraud = df[df['amount'] == 5]
not_fraud = df[df['amount'] >10]

print(fraud.shape,not_fraud.shape)

x = df.drop(["amount" , "date", "description" , "status", "type" ], axis = 1)
y = df["amount"]
print(x)
print(y)
 
print(x.shape,y.shape)

x.head()

